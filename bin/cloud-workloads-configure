#!/usr/bin/env python

import getpass
import netifaces
import paramiko
import pprint


def interfaces_list():
    """
    Returns a sorted, filtered list of interfaces on this machine.

    @return list

    """
    filtered = set(['lo'])
    interfaces = [i for i in netifaces.interfaces() if i not in filtered]
    interfaces.sort()
    return interfaces

def get_input(prompt, default=""):
    """
    Prompts the user for input according to prompt. Allows the use of a
    default.

    @param prompt - String
    @param default - String
    @return string

    """
    result = raw_input(prompt)
    if not result:
        result = default
    return result

def get_yes_no(prompt, default_yes=False):
    """
    Returns true for yes, false otherwise.
    Asks the user to enter yes or no from the prompt.
    The default can be set to yes, otherwise it is no.

    @param prompt - String to display to user when asking for yes or no.
    @param default_yes - Set to true to default user's answer to yes
    @return Boolean

    """
    default = 'y' if default_yes else 'n'
    result = get_input(prompt, default)
    result = result.lower()
    if result[0] == 'y':
        return True
    return False

def choose_interface(label, default='eth0'):
    """
    Prompts the user to choose a network interface corresponding
    to the provided label.

    @param label - String label
    @param default - Default value
    @return String

    """
    interfaces = interfaces_list()
    interface = None
    while interface not in interfaces:
        prompt = "%s interface for minions(default %s): " % (label, default)
        interface = get_input(prompt.capitalize(), default)

        # We can break if interface is in the list
        if interface in interfaces:
            break

        # If interface is not in the list, double check to confirm
        if get_yes_no("Are you sure you wish to use %s as your %s"
                      " interface?(Y/n Default Y): " % (interface, label),
                      default_yes=True):
            break

    return interface


def configure_interfaces():
    """
    Presents a list of interfaces available on this machine and asks
    the user to choose a "public" and a "private" interface that do
    not have to exist on this machine.

    @TODO - Write pillar interfaces file with the results

    """

    # Choose public and private interfaces
    interfaces = interfaces_list()

    print "Available Interfaces on this machine: ", interfaces
    print ("Note: The interfaces available here might not be the same as "
           "on your minions.\n")

    default = interfaces[0]
    interface_public = choose_interface('public', default)

    if len(interfaces) > 1:
        default = [i for i in interfaces if i != interface_public][0]
    interface_private = choose_interface('private', default)

    print "Public: %s\nPrivate: %s\n" % (interface_public, interface_private)


def configure_salt_user():
    """
    Allows the user to type a username and a password. When applying states
    via stand alone salt, this user will be created and templated into
    the salt master config.

    """
    prompt = "Salt user: (default saltysomeone): "
    saltuser = get_input(prompt, default="saltysomeone")

    saltpasswd = None
    confirmpasswd = None
    while not saltpasswd or saltpasswd != confirmpasswd:
        prompt = "\nPassword for %s: " % saltuser
        saltpasswd = getpass.getpass(prompt)

        prompt = "Confirm password for %s: " % saltuser
        confirmpasswd = getpass.getpass(prompt)

        if not saltpasswd:
            print "Invalid password. Please try again."
            continue

        if saltpasswd != confirmpasswd:
            print "Passwords do not match. Please try again."
            continue

        break

    print "Salt user: %s\n" % saltuser


def ssh_connect_kwargs(user, passwd=None):
    kwargs = {
        'username': user,
    }
    if passwd:
        kwargs.update(password=passwd)
    return kwargs


def test_sftp(host, user, passwd=None, port=22):
    #try:
    print "Testing sftp to %s with user %s on port %s" % (host, user, port)
    transport = paramiko.Transport((host, port))
    connect_kwargs = ssh_connect_kwargs(user, passwd)
    transport.connect(**connect_kwargs)
    sftp = paramiko.SFTPClient.from_transport(transport)
    sftp.close()
    transport.close()
    return True
    #except Exception as e:
    #    print ("Sftp to %s with user %s on port %s failed because: "
    #           "%s - %s" % (host, user, port, type(e), str(e)))
    return False


def test_ssh_sudo(host, user, passwd=None):
    try:
        print "Testing ssh connection with sudo to %s with user %s" % (host, user)
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        connect_kwargs = ssh_connect_kwargs(user, passwd)
        connect_kwargs['timeout'] = 5
        ssh.connect(host, **connect_kwargs)
        stdin, stdout, stderr = ssh.exec_command("sudo whoami")
        result = stdout.read().rstrip()
        print "Std out for \"sudo whoami\""
        print result
        ssh.close()
        if result == "root":
            return True
    except Exception as e:
        print ("SSH connection with sudo to %s with user %s failed "
               "because: %s - %s" % (host, user, type(e), str(e)))
    return False


def get_minion_info(previous_minion_info):

    previous_user = previous_minion_info.get('user')
    previous_passwd = previous_minion_info.get('passwd')

    # Get host
    while(True):
        prompt = "Host: "
        host = get_input(prompt, default="")
        if not host:
            print "Invalid host"
        else:
            break

    # Get user
    while(True):
        prompt = "User(default %s): " % previous_user if previous_user else "User: "
        user = get_input(prompt, previous_user)
        if not user:
            print "Invalid user"
        else:
            break

    # Provide password?
    prompt = "Use a password for user %s(Y/n default yes): " % user
    use_passwd = get_yes_no(prompt, default_yes=True)

    # Get optional password
    if use_passwd:
        prompt = "Password: " if not previous_passwd else "Password(default to previous): "
        passwd = getpass.getpass(prompt)
        if not passwd:
            passwd = previous_passwd

    minion_dict = {
        'host': host,
        'user': user,
        'sudo': True,
        'timeout': 360
    }

    if use_passwd:
        minion_dict.update(passwd=passwd)

    return minion_dict

def configure_salt_roster():
    """
    Creates a roster file to use with salt-ssh from user supplied input.
    Users should be able to provide connection info for as many minions
    as they wish.

    """
    # Build roster information
    roster = {}
    minion_info = {}
    id_ = 1
    while(True):

        print "Collecting for minion %s" % id_
        minion_info = get_minion_info(minion_info)

        prompt = "Test connection?(Y/n default Y): "
        if get_yes_no(prompt, default_yes=True):

            passed_sftp = False
            passed_sudo = test_ssh_sudo(minion_info['host'], minion_info['user'], passwd=minion_info.get('passwd'))
            if passed_sudo:
                passed_sftp = test_sftp(minion_info['host'], minion_info['user'], passwd=minion_info.get('passwd'))

            if not passed_sftp:
                print "Please reenter the connection information."
                continue

        roster.update({
            'minion%s' % id_: minion_info
        })

        prompt = "Add another minion?(Y/n default Y): "
        if not get_yes_no(prompt, default_yes=True):
            break

        id_ += 1

    pprint.pprint(roster)


if __name__ == "__main__":

    
    print "\nWelcome to the Cloud Workloads Configuration utility."

    print ("\nCloud Workloads requires minions that are running workloads to "
           "have similar network interfaces. Minions should have a public and "
           "a private interface.")
    prompt = "Configure public and private interfaces now? (Y/n Default Y): "
    if get_yes_no(prompt, default_yes=True):
        configure_interfaces()

    print ("\nCloud Workloads requires a user for external authentication with "
           "salt using pam.")
    prompt = "Configure external auth user for salt now? (Y/n Default Y): "
    if get_yes_no(prompt, default_yes=True):
        configure_salt_user()

    print ("\nCloud Workloads will, by default, require 7 minions to execute "
           "workloads. Each minion will need to run the salt-minion service "
           "and be connected to the salt-master service running on this "
           "machine. Cloud Workloads can setup salt-minion on your minions "
           "for you but will need connection information.")
    prompt = "Configure ssh connection information now? (Y/n Default Y): "
    if get_yes_no(prompt, default_yes=True):
        configure_salt_roster()
